<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ghost Avatar</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a2e;
    display: flex; align-items: center; justify-content: center;
    height: 100vh; overflow: hidden;
    font-family: system-ui, sans-serif;
  }
  body.widget { background: transparent; }
  #avatar {
    width: min(80vw, 80vh);
    height: min(80vw, 80vh);
    max-width: 500px; max-height: 500px;
  }
  body.widget #avatar { width: 100vw; height: 100vh; max-width: none; max-height: none; }
  #status {
    position: fixed; top: 16px; right: 16px;
    width: 8px; height: 8px; border-radius: 50%;
    background: #ccc; transition: background 0.3s;
  }
  #status.connected { background: #7cb88a; }
  #status.disconnected { background: #d48888; }
  body.widget #status, body.widget #debug { display: none; }
  #debug {
    position: fixed; bottom: 12px; left: 12px;
    color: #bbb; font: 10px monospace; pointer-events: none;
  }
</style>
</head>
<body>
<script>if (location.search.includes('widget')) document.body.classList.add('widget');</script>
<div id="status" class="disconnected"></div>
<div id="debug">haunting...</div>

<svg id="avatar" viewBox="0 0 400 500" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <!-- Soft outer glow for ghostly feel -->
    <filter id="ghost-glow" x="-40%" y="-40%" width="180%" height="180%">
      <feGaussianBlur stdDeviation="12" result="blur"/>
      <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
    </filter>
    <filter id="glow-soft" x="-30%" y="-30%" width="160%" height="160%">
      <feGaussianBlur stdDeviation="4" result="blur"/>
      <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
    </filter>
    <filter id="cheek-blur" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="6"/>
    </filter>

    <!-- Radial gradient for ghostly body -->
    <radialGradient id="body-grad" cx="50%" cy="35%" r="55%">
      <stop id="body-grad-inner" offset="0%" stop-color="#f0eaf6"/>
      <stop id="body-grad-mid" offset="50%" stop-color="#e8e0f0"/>
      <stop id="body-grad-outer" offset="100%" stop-color="#d4c8e8"/>
    </radialGradient>

    <!-- Inner highlight shimmer -->
    <radialGradient id="body-highlight" cx="40%" cy="30%" r="40%">
      <stop offset="0%" stop-color="#ffffff" stop-opacity="0.3"/>
      <stop offset="100%" stop-color="#ffffff" stop-opacity="0"/>
    </radialGradient>
  </defs>

  <g id="ghost-group">

    <!-- ===== OUTER GLOW (atmospheric) ===== -->
    <ellipse id="outer-glow" cx="200" cy="240" rx="100" ry="120"
             fill="#d4c8e8" opacity="0.15" filter="url(#ghost-glow)"/>

    <!-- ===== GHOST BODY ===== -->
    <!-- The body is a single path: dome top + wavy bottom edge -->
    <!-- Built dynamically by JS, but we set a default shape here -->
    <path id="ghost-body" d="
      M 110 260
      Q 110 120, 200 110
      Q 290 120, 290 260
      L 290 340
      Q 270 320, 250 340
      Q 230 360, 210 340
      Q 190 320, 170 340
      Q 150 360, 130 340
      Q 110 320, 110 340
      Z
    " fill="url(#body-grad)" opacity="0.9" filter="url(#glow-soft)"/>

    <!-- Inner highlight overlay -->
    <path id="ghost-highlight" d="
      M 110 260
      Q 110 120, 200 110
      Q 290 120, 290 260
      L 290 340
      Q 270 320, 250 340
      Q 230 360, 210 340
      Q 190 320, 170 340
      Q 150 360, 130 340
      Q 110 320, 110 340
      Z
    " fill="url(#body-highlight)" opacity="0.5"/>

    <!-- ===== CHEEK BLUSH (hidden by default) ===== -->
    <ellipse id="blush-l" cx="148" cy="280" rx="18" ry="10" fill="#ffb0c0" opacity="0" filter="url(#cheek-blur)"/>
    <ellipse id="blush-r" cx="252" cy="280" rx="18" ry="10" fill="#ffb0c0" opacity="0" filter="url(#cheek-blur)"/>

    <!-- ===== EYES ===== -->
    <!-- Left eye white -->
    <ellipse id="eye-l-white" cx="162" cy="230" rx="24" ry="26" fill="#ffffff" opacity="0.95"/>
    <!-- Left eye pupil (black dot) -->
    <circle id="eye-l-pupil" cx="162" cy="232" r="10" fill="#2a2035"/>
    <!-- Left eye highlight -->
    <circle id="eye-l-sparkle" cx="167" cy="226" r="4" fill="#ffffff" opacity="0.9"/>

    <!-- Right eye white -->
    <ellipse id="eye-r-white" cx="238" cy="230" rx="24" ry="26" fill="#ffffff" opacity="0.95"/>
    <!-- Right eye pupil (black dot) -->
    <circle id="eye-r-pupil" cx="238" cy="232" r="10" fill="#2a2035"/>
    <!-- Right eye highlight -->
    <circle id="eye-r-sparkle" cx="243" cy="226" r="4" fill="#ffffff" opacity="0.9"/>

    <!-- Happy eye arcs (^_^) - drawn over the eyes when happy, hidden by default -->
    <path id="eye-l-happy" d="M 140 232 Q 162 212, 184 232" stroke="#2a2035" stroke-width="5" stroke-linecap="round" fill="none" opacity="0"/>
    <path id="eye-r-happy" d="M 216 232 Q 238 212, 260 232" stroke="#2a2035" stroke-width="5" stroke-linecap="round" fill="none" opacity="0"/>

    <!-- ===== MOUTH ===== -->
    <!-- Small round "o" mouth -->
    <ellipse id="mouth" cx="200" cy="290" rx="10" ry="12" fill="#8a7098" opacity="0.8"/>
    <!-- Inner mouth darker -->
    <ellipse id="mouth-inner" cx="200" cy="291" rx="7" ry="9" fill="#5a4068" opacity="0.7"/>

  </g><!-- /ghost-group -->
</svg>

<!-- ===== WebSocket ===== -->
<script>
var expressState = {
  target:  { valence: 0, arousal: 0, dominance: 0, genuine: true, asymmetry: 0, intensity: 0.5 },
  current: { valence: 0, arousal: 0, dominance: 0, genuine: true, asymmetry: 0, intensity: 0.5 },
  lastTime: performance.now()
};
var statusEl = document.getElementById('status');
var debugEl  = document.getElementById('debug');
var reconnectDelay = 500;

function wsConnect() {
  debugEl.textContent = 'connecting...';
  var ws = new WebSocket('ws://localhost:3456');
  ws.onopen = function() {
    statusEl.className = 'connected';
    reconnectDelay = 500;
    debugEl.textContent = 'connected';
  };
  ws.onmessage = function(e) {
    try {
      var d = JSON.parse(e.data);
      var t = expressState.target;
      t.valence   = d.valence   != null ? d.valence   : 0;
      t.arousal   = d.arousal   != null ? d.arousal   : 0;
      t.dominance = d.dominance != null ? d.dominance : 0;
      t.genuine   = d.genuine   != null ? d.genuine   : true;
      t.asymmetry = d.asymmetry != null ? d.asymmetry : 0;
      t.intensity = d.intensity != null ? d.intensity : 0.5;
      expressState.lastTime = performance.now();
      debugEl.textContent = 'v=' + d.valence.toFixed(2) + ' a=' + d.arousal.toFixed(2) +
        ' d=' + d.dominance.toFixed(2) + ' g=' + d.genuine +
        ' as=' + d.asymmetry.toFixed(2) + ' i=' + d.intensity.toFixed(2);
    } catch(err) { debugEl.textContent = 'err: ' + err.message; }
  };
  ws.onclose = function() {
    statusEl.className = 'disconnected';
    debugEl.textContent = 'disconnected';
    setTimeout(wsConnect, reconnectDelay);
    reconnectDelay = Math.min(reconnectDelay * 1.5, 5000);
  };
  ws.onerror = function() { ws.close(); };
}
wsConnect();
</script>

<!-- ===== Animation Engine ===== -->
<script>
(function() {
  var DECAY_DELAY = 4000;
  var DECAY_RATE  = 0.003;
  var LERP_SPEED  = 0.08;

  function lerp(a, b, t) { return a + (b - a) * t; }
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

  // ── SVG element references ──
  var el = {
    ghostGroup:  document.getElementById('ghost-group'),
    outerGlow:   document.getElementById('outer-glow'),
    body:        document.getElementById('ghost-body'),
    highlight:   document.getElementById('ghost-highlight'),
    // Eyes
    eyeLWhite:   document.getElementById('eye-l-white'),
    eyeRWhite:   document.getElementById('eye-r-white'),
    eyeLPupil:   document.getElementById('eye-l-pupil'),
    eyeRPupil:   document.getElementById('eye-r-pupil'),
    eyeLSparkle: document.getElementById('eye-l-sparkle'),
    eyeRSparkle: document.getElementById('eye-r-sparkle'),
    eyeLHappy:   document.getElementById('eye-l-happy'),
    eyeRHappy:   document.getElementById('eye-r-happy'),
    // Mouth
    mouth:       document.getElementById('mouth'),
    mouthInner:  document.getElementById('mouth-inner'),
    // Blush
    blushL:      document.getElementById('blush-l'),
    blushR:      document.getElementById('blush-r'),
    // Gradient stops
    bodyGradInner: document.getElementById('body-grad-inner'),
    bodyGradMid:   document.getElementById('body-grad-mid'),
    bodyGradOuter: document.getElementById('body-grad-outer'),
  };

  // ── Animation state (all lerped smoothly) ──
  var anim = {
    // Floating / bob
    bobY: 0,           // vertical offset from idle bob
    bobSpeed: 0.003,   // idle bob speed
    bobAmount: 8,      // idle bob amplitude

    // Body shape
    bodyScaleX: 1.0,   // horizontal body scale
    bodyScaleY: 1.0,   // vertical body scale (stretch/squish)
    bodyTilt: 0,       // rotation degrees

    // Body float height (emotion-driven offset)
    floatY: 0,

    // Wave bottom edge params (5 scallop points)
    waveAmplitude: 20,  // how wavy the bottom is
    waveSpeed: 0.004,   // undulation speed
    waveAsymmetry: 0,   // asymmetric wave offset

    // Eyes
    eyeWhiteRx: 24,     // eye white horizontal radius
    eyeWhiteRy: 26,     // eye white vertical radius
    eyePupilR: 10,       // pupil radius
    eyeYOffset: 0,       // vertical eye shift
    eyeLSquint: 0,       // left eye squint (0=open, 1=fully squinted to happy arc)
    eyeRSquint: 0,       // right eye squint
    eyeLWide: 0,         // left eye widened (0=normal, 1=maximum wide)
    eyeRWide: 0,
    pupilShrink: 0,      // 0=normal, 1=tiny pupils (scared)

    // Happy arc visibility (replaces round eyes)
    happyL: 0,
    happyR: 0,

    // Mouth
    mouthRx: 10,         // mouth horizontal radius
    mouthRy: 12,         // mouth vertical radius
    mouthY: 290,         // mouth vertical position

    // Blush
    blush: 0,

    // Glow
    glowOpacity: 0.15,
    glowRadius: 100,

    // Body color (interpolation factors)
    bodyBrightness: 0,   // -1 = dark/sad, 0 = neutral, 1 = bright/happy
    bodyHue: 0,          // 0 = lavender, shifts with emotion

    // Body opacity
    bodyOpacity: 0.9,
  };

  var target = {};
  for (var k in anim) target[k] = anim[k];

  // Time tracking
  var timeAccum = 0;
  var lastFrameTime = performance.now();

  // ── Compute animation targets from expression parameters ──
  function computeTargets(v, a, d, g, asym, inten) {
    var i = clamp(inten * 2.0, 0.2, 2.0);

    // ============================================================
    // FLOATING HEIGHT - valence drives vertical position
    // ============================================================
    // Happy = floats higher, sad = sinks lower
    target.floatY = -v * 15 * i;

    // ============================================================
    // BOB SPEED & AMOUNT - arousal drives animation energy
    // ============================================================
    // High arousal = fast, big bobs. Low arousal = slow, gentle
    target.bobSpeed = 0.003 + clamp(a, -0.5, 1) * 0.004 * i;
    target.bobAmount = 8 + a * 6 * i;
    if (a < 0) target.bobAmount = Math.max(3, 8 + a * 4); // Still some bob even when calm

    // ============================================================
    // BODY SHAPE - arousal + dominance
    // ============================================================
    // High arousal = stretch taller
    // Low arousal = squish shorter/wider
    target.bodyScaleY = 1.0 + a * 0.12 * i;
    target.bodyScaleX = 1.0 - a * 0.06 * i;

    // Dominance: confident = puff up, uncertain = shrink
    target.bodyScaleX += d * 0.08 * i;
    target.bodyScaleY += d * 0.04 * i;

    // Clamp
    target.bodyScaleX = clamp(target.bodyScaleX, 0.8, 1.25);
    target.bodyScaleY = clamp(target.bodyScaleY, 0.82, 1.2);

    // Tilt from asymmetry
    target.bodyTilt = asym * 8 * i;

    // ============================================================
    // WAVY BOTTOM EDGE
    // ============================================================
    target.waveAmplitude = 18 + a * 8 * i; // More energetic = bigger waves
    target.waveSpeed = 0.004 + clamp(a, -0.3, 1) * 0.003 * i;
    target.waveAsymmetry = asym * 10 * i;

    // ============================================================
    // EYES - the soul of the ghost
    // ============================================================

    // Reset
    target.eyeLSquint = 0;
    target.eyeRSquint = 0;
    target.eyeLWide = 0;
    target.eyeRWide = 0;
    target.happyL = 0;
    target.happyR = 0;
    target.pupilShrink = 0;

    // Base eye size
    target.eyeWhiteRx = 24;
    target.eyeWhiteRy = 26;
    target.eyePupilR = 10;
    target.eyeYOffset = 0;

    // --- HAPPY EYES: crescents (^_^) ---
    if (v > 0.15 && g) {
      var happyAmt = clamp((v - 0.15) * 1.8 * i, 0, 1);
      target.happyL = happyAmt;
      target.happyR = happyAmt;
    }

    // --- NON-GENUINE: eyes stay round (forced smile) ---
    if (v > 0.15 && !g) {
      target.happyL = 0;
      target.happyR = 0;
      // Slight widening for uncanny effect
      target.eyeLWide = clamp(v * 0.3 * i, 0, 0.5);
      target.eyeRWide = clamp(v * 0.3 * i, 0, 0.5);
    }

    // --- WORRIED/SAD EYES: droopy, look down ---
    if (v < -0.2) {
      target.eyeYOffset = clamp((-v - 0.2) * 6 * i, 0, 8);
      // Slightly smaller eyes when sad
      target.eyeWhiteRy = 26 - (-v - 0.2) * 6 * i;
      // Pupils slightly larger (puppy eyes)
      target.eyePupilR = 10 + (-v - 0.2) * 3 * i;
    }

    // --- HIGH AROUSAL: eyes go wide ---
    if (a > 0.3) {
      var wideAmt = clamp((a - 0.3) * 1.5 * i, 0, 1);
      target.eyeLWide = Math.max(target.eyeLWide, wideAmt);
      target.eyeRWide = Math.max(target.eyeRWide, wideAmt);
      target.eyeWhiteRy = Math.max(target.eyeWhiteRy, 26 + a * 8 * i);
      target.eyeWhiteRx = Math.max(target.eyeWhiteRx, 24 + a * 4 * i);
    }

    // --- LOW AROUSAL: eyes droop ---
    if (a < -0.2) {
      var droopAmt = clamp((-a - 0.2) * 1.5 * i, 0, 1);
      target.eyeLSquint = Math.max(target.eyeLSquint, droopAmt * 0.6);
      target.eyeRSquint = Math.max(target.eyeRSquint, droopAmt * 0.6);
      target.eyeWhiteRy = Math.min(target.eyeWhiteRy, 26 - (-a) * 10 * i);
    }

    // --- DOMINANCE: confident = narrow determined, uncertain = huge round ---
    if (d > 0.3) {
      var narrowAmt = clamp((d - 0.3) * 1.5 * i, 0, 0.6);
      target.eyeLSquint = Math.max(target.eyeLSquint, narrowAmt);
      target.eyeRSquint = Math.max(target.eyeRSquint, narrowAmt);
      target.eyeWhiteRy = Math.min(target.eyeWhiteRy, 26 - (d - 0.3) * 8 * i);
    }
    if (d < -0.3) {
      var hugeAmt = clamp((-d - 0.3) * 1.5 * i, 0, 1);
      target.eyeLWide = Math.max(target.eyeLWide, hugeAmt);
      target.eyeRWide = Math.max(target.eyeRWide, hugeAmt);
      target.eyeWhiteRy = Math.max(target.eyeWhiteRy, 26 + (-d) * 6 * i);
      target.eyeWhiteRx = Math.max(target.eyeWhiteRx, 24 + (-d) * 4 * i);
      target.eyePupilR = Math.max(target.eyePupilR, 10 + (-d - 0.3) * 4 * i);
      // Tiny pupils if scared (high arousal + low dominance)
      if (a > 0.3) {
        target.pupilShrink = clamp(Math.min(a, -d) * 0.8 * i, 0, 0.7);
      }
    }

    // --- ASYMMETRY: one eye different ---
    if (Math.abs(asym) > 0.15) {
      var asymAmt = Math.abs(asym) * i;
      if (asym > 0) {
        // Right eye more squinted / left more open
        target.eyeRSquint += asymAmt * 0.4;
        target.eyeLWide += asymAmt * 0.2;
      } else {
        target.eyeLSquint += asymAmt * 0.4;
        target.eyeRWide += asymAmt * 0.2;
      }
    }

    // Clamp all eye values
    target.eyeLSquint = clamp(target.eyeLSquint, 0, 1);
    target.eyeRSquint = clamp(target.eyeRSquint, 0, 1);
    target.eyeLWide = clamp(target.eyeLWide, 0, 1);
    target.eyeRWide = clamp(target.eyeRWide, 0, 1);
    target.happyL = clamp(target.happyL, 0, 1);
    target.happyR = clamp(target.happyR, 0, 1);
    target.eyeWhiteRx = clamp(target.eyeWhiteRx, 16, 36);
    target.eyeWhiteRy = clamp(target.eyeWhiteRy, 14, 38);
    target.eyePupilR = clamp(target.eyePupilR, 4, 16);

    // ============================================================
    // MOUTH
    // ============================================================
    // Positive valence: wider mouth (smile-ish "o")
    // Negative valence: tighter, smaller mouth
    // High arousal: mouth opens taller (gasp!)
    // Low arousal: small, relaxed mouth

    target.mouthRx = 10;
    target.mouthRy = 12;
    target.mouthY = 290;

    if (v > 0) {
      // Happy: wider and slightly shorter (gentle smile shape)
      target.mouthRx = 10 + v * 6 * i;
      target.mouthRy = 12 - v * 3 * i;
      target.mouthY = 290 - v * 4 * i; // Rises slightly
    } else {
      // Sad/negative: smaller, lower
      target.mouthRx = 10 + v * 3 * i; // Gets smaller (v negative)
      target.mouthRy = 12 + v * 2 * i; // Gets smaller
      target.mouthY = 290 - v * 3 * i; // Drops lower (v negative => +offset)
    }

    // Arousal: high = mouth opens wide (surprise "O!")
    if (a > 0.3) {
      target.mouthRy = Math.max(target.mouthRy, 12 + (a - 0.3) * 14 * i);
      target.mouthRx = Math.max(target.mouthRx, 10 + (a - 0.3) * 4 * i);
    }
    // Low arousal: tiny mouth
    if (a < -0.3) {
      target.mouthRy = Math.min(target.mouthRy, 12 + (a + 0.3) * 6 * i); // Shrinks
      target.mouthRx = Math.min(target.mouthRx, 10 + (a + 0.3) * 4 * i);
    }

    target.mouthRx = clamp(target.mouthRx, 4, 22);
    target.mouthRy = clamp(target.mouthRy, 4, 24);

    // ============================================================
    // BLUSH - rosy cheeks when genuinely happy
    // ============================================================
    target.blush = (g && v > 0.2) ? clamp((v - 0.2) * 1.5 * i, 0, 0.55) : 0;

    // ============================================================
    // GLOW - brighter when happy, dimmer when sad
    // ============================================================
    target.glowOpacity = 0.15 + v * 0.12 * i;
    target.glowOpacity = clamp(target.glowOpacity, 0.03, 0.35);
    target.glowRadius = 100 + v * 20 * i + a * 10 * i;

    // ============================================================
    // BODY BRIGHTNESS & COLOR
    // ============================================================
    target.bodyBrightness = v * 0.5 * i; // positive = brighter, negative = darker
    target.bodyOpacity = 0.9 + v * 0.05 * i; // Slightly more opaque when happy
    target.bodyOpacity = clamp(target.bodyOpacity, 0.75, 0.95);
  }

  // ── Build ghost body SVG path with wavy bottom ──
  function buildBodyPath(scaleX, scaleY, waveAmp, wavePhase, waveAsym) {
    // Center of ghost at x=200
    var cx = 200;
    var baseTop = 110;
    var baseBottom = 350;
    var baseWidth = 90; // half-width

    // Apply scale
    var hw = baseWidth * scaleX;
    var top = baseTop;
    var bot = baseBottom * scaleY + (1 - scaleY) * 230; // Scale from midpoint
    var mid = (top + bot) * 0.5;

    // Left and right edges
    var lx = cx - hw;
    var rx = cx + hw;

    // Dome: quadratic bezier from left side up and over
    // We go: left-mid -> top -> right-mid
    var domeCtrlY = top - hw * 0.3; // How rounded the dome is

    // Wavy bottom: 5 scallops
    var numScallops = 5;
    var scWidth = (rx - lx) / numScallops;
    var waveParts = '';

    for (var si = 0; si < numScallops; si++) {
      var sx = lx + si * scWidth;
      var ex = sx + scWidth;
      var mx = (sx + ex) / 2;
      // Alternate up and down, shifted by phase
      var dir = ((si % 2 === 0) ? 1 : -1);
      // Asymmetry shifts the wave on one side vs the other
      var sideOffset = ((sx + ex) / 2 - cx) / hw; // -1 to 1
      var localAmp = waveAmp + waveAsym * sideOffset;
      var localPhase = wavePhase + si * 0.8;
      var waveY = bot + dir * localAmp * (0.6 + 0.4 * Math.sin(localPhase));

      if (si === 0) {
        waveParts += ' L ' + sx.toFixed(1) + ' ' + bot.toFixed(1);
      }
      waveParts += ' Q ' + mx.toFixed(1) + ' ' + waveY.toFixed(1) +
                   ', ' + ex.toFixed(1) + ' ' + bot.toFixed(1);
    }

    // Build full path
    var path = 'M ' + lx.toFixed(1) + ' ' + mid.toFixed(1);
    // Dome (left side up, across top, down right side)
    path += ' Q ' + lx.toFixed(1) + ' ' + domeCtrlY.toFixed(1) +
            ', ' + cx.toFixed(1) + ' ' + (top).toFixed(1);
    path += ' Q ' + rx.toFixed(1) + ' ' + domeCtrlY.toFixed(1) +
            ', ' + rx.toFixed(1) + ' ' + mid.toFixed(1);
    // Down right side to bottom
    path += ' L ' + rx.toFixed(1) + ' ' + bot.toFixed(1);
    // Wavy bottom (right to left)
    // Actually, let's go left to right for the wave
    // We need to go from rx,bot back to lx,bot with waves

    // Rebuild: go from right side down, then wave from right to left
    var wavePartsRL = '';
    for (var si2 = numScallops - 1; si2 >= 0; si2--) {
      var sx2 = lx + si2 * scWidth;
      var ex2 = sx2 + scWidth;
      var mx2 = (sx2 + ex2) / 2;
      var dir2 = ((si2 % 2 === 0) ? 1 : -1);
      var sideOffset2 = ((sx2 + ex2) / 2 - cx) / hw;
      var localAmp2 = waveAmp + waveAsym * sideOffset2;
      var localPhase2 = wavePhase + si2 * 0.8;
      var waveY2 = bot + dir2 * localAmp2 * (0.6 + 0.4 * Math.sin(localPhase2));

      // Going right to left: from ex2 to sx2, control at mx2
      wavePartsRL += ' Q ' + mx2.toFixed(1) + ' ' + waveY2.toFixed(1) +
                     ', ' + sx2.toFixed(1) + ' ' + bot.toFixed(1);
    }

    path = 'M ' + lx.toFixed(1) + ' ' + mid.toFixed(1);
    path += ' Q ' + lx.toFixed(1) + ' ' + domeCtrlY.toFixed(1) +
            ', ' + cx.toFixed(1) + ' ' + top.toFixed(1);
    path += ' Q ' + rx.toFixed(1) + ' ' + domeCtrlY.toFixed(1) +
            ', ' + rx.toFixed(1) + ' ' + mid.toFixed(1);
    path += ' L ' + rx.toFixed(1) + ' ' + bot.toFixed(1);
    path += wavePartsRL;
    path += ' Z';

    return path;
  }

  // ── Color helpers ──
  function lerpColor3(r1, g1, b1, r2, g2, b2, t) {
    return [
      Math.round(r1 + (r2 - r1) * t),
      Math.round(g1 + (g2 - g1) * t),
      Math.round(b1 + (b2 - b1) * t)
    ];
  }

  function rgbStr(r, g, b) {
    return 'rgb(' + clamp(r, 0, 255) + ',' + clamp(g, 0, 255) + ',' + clamp(b, 0, 255) + ')';
  }

  // ── Idle blink ──
  var blinkTimer = 0;
  var blinkInterval = 3000 + Math.random() * 4000;
  var isBlinking = false;
  var blinkProgress = 0;
  var blinkAmountL = 0;
  var blinkAmountR = 0;

  function handleBlink(dt) {
    blinkTimer += dt;
    if (!isBlinking && blinkTimer > blinkInterval) {
      isBlinking = true;
      blinkProgress = 0;
      blinkTimer = 0;
      blinkInterval = 2500 + Math.random() * 5000;
    }
    if (isBlinking) {
      blinkProgress += dt * 0.007;
      if (blinkProgress < 1) {
        var blink = Math.sin(blinkProgress * Math.PI);
        blinkAmountL = blink;
        blinkAmountR = blink;
      } else {
        isBlinking = false;
        blinkAmountL = 0;
        blinkAmountR = 0;
      }
    }
  }

  // ── Update SVG elements ──
  function updateSVG(dt) {
    timeAccum += dt;

    // ── Idle bobbing ──
    var bobPhase = timeAccum * anim.bobSpeed;
    var bobOffset = Math.sin(bobPhase * 2 * Math.PI) * anim.bobAmount;
    var totalY = anim.floatY + bobOffset;

    // ── Wave phase ──
    var wavePhase = timeAccum * anim.waveSpeed * 2 * Math.PI;

    // ── Build body path ──
    var bodyPath = buildBodyPath(
      anim.bodyScaleX,
      anim.bodyScaleY,
      anim.waveAmplitude,
      wavePhase,
      anim.waveAsymmetry
    );
    el.body.setAttribute('d', bodyPath);
    el.highlight.setAttribute('d', bodyPath);

    // ── Position entire ghost (bob + float + tilt) ──
    el.ghostGroup.setAttribute('transform',
      'translate(0,' + totalY.toFixed(1) + ') rotate(' + anim.bodyTilt.toFixed(1) + ' 200 250)');

    // ── Body opacity ──
    el.body.setAttribute('opacity', anim.bodyOpacity.toFixed(3));

    // ── Body color (gradient stops) ──
    // Base colors: inner=#f0eaf6, mid=#e8e0f0, outer=#d4c8e8
    var bright = anim.bodyBrightness;
    var innerR, innerG, innerB, midR, midG, midB, outerR, outerG, outerB;

    if (bright >= 0) {
      // Brighter: shift toward warm white / soft pink
      var c = lerpColor3(240, 234, 246, 255, 248, 255, bright);
      innerR = c[0]; innerG = c[1]; innerB = c[2];
      c = lerpColor3(232, 224, 240, 250, 240, 255, bright);
      midR = c[0]; midG = c[1]; midB = c[2];
      c = lerpColor3(212, 200, 232, 240, 225, 248, bright);
      outerR = c[0]; outerG = c[1]; outerB = c[2];
    } else {
      // Darker: shift toward blue-grey
      var d2 = -bright;
      var c2 = lerpColor3(240, 234, 246, 180, 175, 200, d2);
      innerR = c2[0]; innerG = c2[1]; innerB = c2[2];
      c2 = lerpColor3(232, 224, 240, 160, 155, 185, d2);
      midR = c2[0]; midG = c2[1]; midB = c2[2];
      c2 = lerpColor3(212, 200, 232, 130, 125, 160, d2);
      outerR = c2[0]; outerG = c2[1]; outerB = c2[2];
    }

    el.bodyGradInner.setAttribute('stop-color', rgbStr(innerR, innerG, innerB));
    el.bodyGradMid.setAttribute('stop-color', rgbStr(midR, midG, midB));
    el.bodyGradOuter.setAttribute('stop-color', rgbStr(outerR, outerG, outerB));

    // ── Outer glow ──
    el.outerGlow.setAttribute('opacity', anim.glowOpacity.toFixed(3));
    el.outerGlow.setAttribute('rx', anim.glowRadius.toFixed(1));
    el.outerGlow.setAttribute('ry', (anim.glowRadius * 1.2).toFixed(1));
    // Tint glow with emotion
    if (bright >= 0) {
      var glowC = lerpColor3(212, 200, 232, 255, 230, 240, bright);
      el.outerGlow.setAttribute('fill', rgbStr(glowC[0], glowC[1], glowC[2]));
    } else {
      var glowC2 = lerpColor3(212, 200, 232, 140, 140, 180, -bright);
      el.outerGlow.setAttribute('fill', rgbStr(glowC2[0], glowC2[1], glowC2[2]));
    }

    // ── Eyes ──
    var eyeBaseY = 230;
    var eyeY = eyeBaseY + anim.eyeYOffset;

    // Compute effective squint (including blink)
    var effSquintL = clamp(Math.max(anim.eyeLSquint, blinkAmountL), 0, 1);
    var effSquintR = clamp(Math.max(anim.eyeRSquint, blinkAmountR), 0, 1);

    // Eye white scaling based on wide/squint
    var eyeRxL = anim.eyeWhiteRx + anim.eyeLWide * 6 - effSquintL * 4;
    var eyeRyL = anim.eyeWhiteRy + anim.eyeLWide * 8 - effSquintL * 18;
    var eyeRxR = anim.eyeWhiteRx + anim.eyeRWide * 6 - effSquintR * 4;
    var eyeRyR = anim.eyeWhiteRy + anim.eyeRWide * 8 - effSquintR * 18;

    // Ensure minimum eye size
    eyeRxL = Math.max(eyeRxL, 6);
    eyeRyL = Math.max(eyeRyL, 2);
    eyeRxR = Math.max(eyeRxR, 6);
    eyeRyR = Math.max(eyeRyR, 2);

    // Pupil size
    var pupilR = anim.eyePupilR * (1 - anim.pupilShrink * 0.6);
    pupilR = clamp(pupilR, 3, Math.min(eyeRyL, eyeRyR) - 2);

    // Compute happy arc blend: when happyL/R is high, fade out round eyes
    var roundOpL = 1 - anim.happyL;
    var roundOpR = 1 - anim.happyR;

    // -- Left eye --
    el.eyeLWhite.setAttribute('cx', '162');
    el.eyeLWhite.setAttribute('cy', eyeY.toFixed(1));
    el.eyeLWhite.setAttribute('rx', eyeRxL.toFixed(1));
    el.eyeLWhite.setAttribute('ry', eyeRyL.toFixed(1));
    el.eyeLWhite.setAttribute('opacity', (0.95 * roundOpL).toFixed(3));

    el.eyeLPupil.setAttribute('cx', '162');
    el.eyeLPupil.setAttribute('cy', (eyeY + 2).toFixed(1));
    el.eyeLPupil.setAttribute('r', (pupilR * roundOpL).toFixed(1));
    el.eyeLPupil.setAttribute('opacity', roundOpL.toFixed(3));

    el.eyeLSparkle.setAttribute('cx', '167');
    el.eyeLSparkle.setAttribute('cy', (eyeY - 4).toFixed(1));
    el.eyeLSparkle.setAttribute('opacity', (0.9 * roundOpL).toFixed(3));
    el.eyeLSparkle.setAttribute('r', (4 + anim.eyeLWide * 2).toFixed(1));

    // -- Right eye --
    el.eyeRWhite.setAttribute('cx', '238');
    el.eyeRWhite.setAttribute('cy', eyeY.toFixed(1));
    el.eyeRWhite.setAttribute('rx', eyeRxR.toFixed(1));
    el.eyeRWhite.setAttribute('ry', eyeRyR.toFixed(1));
    el.eyeRWhite.setAttribute('opacity', (0.95 * roundOpR).toFixed(3));

    el.eyeRPupil.setAttribute('cx', '238');
    el.eyeRPupil.setAttribute('cy', (eyeY + 2).toFixed(1));
    el.eyeRPupil.setAttribute('r', (pupilR * roundOpR).toFixed(1));
    el.eyeRPupil.setAttribute('opacity', roundOpR.toFixed(3));

    el.eyeRSparkle.setAttribute('cx', '243');
    el.eyeRSparkle.setAttribute('cy', (eyeY - 4).toFixed(1));
    el.eyeRSparkle.setAttribute('opacity', (0.9 * roundOpR).toFixed(3));
    el.eyeRSparkle.setAttribute('r', (4 + anim.eyeRWide * 2).toFixed(1));

    // -- Happy arcs --
    var happyArcY = eyeY + 2;
    el.eyeLHappy.setAttribute('d',
      'M 140 ' + happyArcY.toFixed(1) +
      ' Q 162 ' + (happyArcY - 22).toFixed(1) +
      ', 184 ' + happyArcY.toFixed(1));
    el.eyeRHappy.setAttribute('d',
      'M 216 ' + happyArcY.toFixed(1) +
      ' Q 238 ' + (happyArcY - 22).toFixed(1) +
      ', 260 ' + happyArcY.toFixed(1));
    el.eyeLHappy.setAttribute('opacity', anim.happyL.toFixed(3));
    el.eyeRHappy.setAttribute('opacity', anim.happyR.toFixed(3));
    el.eyeLHappy.setAttribute('stroke-width', (5 + anim.happyL * 2).toFixed(1));
    el.eyeRHappy.setAttribute('stroke-width', (5 + anim.happyR * 2).toFixed(1));

    // ── Mouth ──
    el.mouth.setAttribute('cx', '200');
    el.mouth.setAttribute('cy', anim.mouthY.toFixed(1));
    el.mouth.setAttribute('rx', anim.mouthRx.toFixed(1));
    el.mouth.setAttribute('ry', anim.mouthRy.toFixed(1));

    el.mouthInner.setAttribute('cx', '200');
    el.mouthInner.setAttribute('cy', (anim.mouthY + 1).toFixed(1));
    el.mouthInner.setAttribute('rx', (anim.mouthRx * 0.7).toFixed(1));
    el.mouthInner.setAttribute('ry', (anim.mouthRy * 0.75).toFixed(1));

    // ── Blush ──
    el.blushL.setAttribute('opacity', anim.blush.toFixed(3));
    el.blushR.setAttribute('opacity', anim.blush.toFixed(3));
    // Position blush relative to eye position
    el.blushL.setAttribute('cy', (eyeY + 50).toFixed(1));
    el.blushR.setAttribute('cy', (eyeY + 50).toFixed(1));
  }

  // ── Main animation loop ──
  function animate() {
    requestAnimationFrame(animate);
    var now = performance.now();
    var dt = Math.min(now - lastFrameTime, 50);
    lastFrameTime = now;

    var st = expressState;

    // Decay toward neutral after no input
    if (now - st.lastTime > DECAY_DELAY) {
      st.target.valence   = lerp(st.target.valence,   0, DECAY_RATE);
      st.target.arousal   = lerp(st.target.arousal,   0, DECAY_RATE);
      st.target.dominance = lerp(st.target.dominance, 0, DECAY_RATE);
      st.target.asymmetry = lerp(st.target.asymmetry, 0, DECAY_RATE);
      st.target.intensity = lerp(st.target.intensity,  0.5, DECAY_RATE * 0.5);
    }

    // Lerp emotional state
    st.current.valence   = lerp(st.current.valence,   st.target.valence,   LERP_SPEED);
    st.current.arousal   = lerp(st.current.arousal,   st.target.arousal,   LERP_SPEED);
    st.current.dominance = lerp(st.current.dominance, st.target.dominance, LERP_SPEED);
    st.current.asymmetry = lerp(st.current.asymmetry, st.target.asymmetry, LERP_SPEED);
    st.current.intensity = lerp(st.current.intensity, st.target.intensity, LERP_SPEED);
    st.current.genuine   = st.target.genuine;

    var c = st.current;
    computeTargets(c.valence, c.arousal, c.dominance, c.genuine, c.asymmetry, c.intensity);

    // Lerp all animation values toward targets
    for (var key in anim) {
      if (typeof anim[key] === 'number') {
        anim[key] = lerp(anim[key], target[key], LERP_SPEED * 1.2);
      }
    }

    // Natural idle blink
    handleBlink(dt);

    updateSVG(dt);
  }
  animate();

  // ── Double-click test expressions ──
  var testExprs = [
    { name: 'happy',     valence: 0.9,  arousal: 0.5,  dominance: 0.3, genuine: true,  asymmetry: 0.0,  intensity: 0.85 },
    { name: 'angry',     valence:-0.8,  arousal: 0.7,  dominance: 0.8, genuine: true,  asymmetry: 0.0,  intensity: 0.9  },
    { name: 'surprised', valence: 0.2,  arousal: 0.9,  dominance:-0.7, genuine: true,  asymmetry: 0.0,  intensity: 0.85 },
    { name: 'sleepy',    valence: 0.1,  arousal:-0.9,  dominance:-0.2, genuine: true,  asymmetry: 0.0,  intensity: 0.7  },
    { name: 'curious',   valence: 0.3,  arousal: 0.6,  dominance:-0.3, genuine: true,  asymmetry: 0.3,  intensity: 0.6  },
    { name: 'skeptical', valence:-0.2,  arousal: 0.3,  dominance: 0.5, genuine: false, asymmetry:-0.6,  intensity: 0.65 },
    { name: 'sad',       valence:-0.7,  arousal:-0.4,  dominance:-0.6, genuine: true,  asymmetry: 0.0,  intensity: 0.7  },
    { name: 'neutral',   valence: 0.0,  arousal: 0.0,  dominance: 0.0, genuine: true,  asymmetry: 0.0,  intensity: 0.5  },
  ];
  var testIdx = 0;
  window.addEventListener('dblclick', function() {
    var e = testExprs[testIdx];
    debugEl.textContent = 'test: ' + e.name;
    Object.assign(expressState.target, e);
    expressState.lastTime = performance.now();
    testIdx = (testIdx + 1) % testExprs.length;
  });
})();
</script>
</body>
</html>
